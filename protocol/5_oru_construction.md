# Optimistic Rollup Construction
SpiceNet is designed as an optimistic rollup utilizing ZK fraud proofs to enable full nodes to verify and challenge state. But, let's actually understand what optimistic rollups enable, what they don't, what do fraud proofs actually do, and our path to becoming a full validity rollup.

# Optimistic rollups and their properties
Optimistic rollups are a type of rollup construction which allow the users to optimistically "assume" transaction validity with the help of a trusted sequencer. Optimistic rollups have a set of advantages, such as cheap costs to post transaction data on L1, a simple and conventional construction without much complexities, and (in some cases), faster L1 finality.

However, optimistic rollups tradeoff simplicity and cost advantages with trust assumptions. The sequencer is an actor responsible for collecting, executing, batching and posting transactions, atleast that is what we presume the sequencer does. However, a sequencer also decides the validity of transactions, hence making it a trusted party. This means that users and full nodes of the network have to assume that the sequencer is acting in good faith, and not including malicious, incorrect transactions(such as transactions without signaturs, etc.).

Fraud proofs were invented for the exact purpose. Optimistic rollups with fraud proofs enabled outsource state validation to full nodes, thereby reducing the role of a sequencer to just ordering, batching and offering pre-confirmations. This distributes the workload and removes any trust assumptions involved otherwise. This means that the rollup's state can progress in the optimistic condition, and keeps enjoying the benefits stated above, but can be challenged by full nodes in the condition where the sequencer(the asserter) and the full nodes(the challenger) diverge on validity of transactions.

# How do we design fraud proofs?
Traditional fraud proofs were designed to use an "Interactive Verification Game", a process by which the challenger(the full node) and the asserter(the sequencer), play a systematic game whose objective is to ascertain the specific state transition(s) that the asserter and the challenger disagree on. Each step of the game is represented on the base layer as a transaction which is to be verified. The end result, i.e the invalid mutations represent a fraud proof, which then can be combined with a modified(and correct) state transition to successfully revert an invalid state transition.

However, by the numbers, this process is TERRIBLE. The whole IVG game is represented by about 50 or so transactions on chain, making the whole process tedious, time-consuming and expensive. This is also why a 7-day challenge period is designed, in order to give sufficient buffer for these transactions to be placed on-chain and finalized. 7-day withdrawal periods are definitely not the good UX, and reducing steps in the IVG game construction may introduce vulnerabilities and loopholes.

So, how can we optimize the fraud proof construction? The answer is pretty simple and was laying in plain sight all the time. The answer is ZK Proofs. ZK proofs are extremely cheap to verify on-chain, and will get significantly cheaper in the future. Instead of the ~50 transactions in the IVG construction, the fraud proof enabled by a ZK prover would be represented by a single transaction. This can be achieved because the conflict in state roots computed by the full node and the sequencer caused by the invalid state transition can be accurately proved with the help of a ZK proof, which can be verified in just one transaction. This not only offers cost benefits, but also saves a huge amount of time, which can be upto ~50x, which allows us to cut down on the challenge period from 7 days to just a few hours. Normally it doesn't take much time to generate a proof(a few minutes at maximum) and verify it(another few minutes), we are providing an additional buffer by setting the challenge period to ~8 hours, to account for any warm-up periods in the prover.

# Other problems with ORUs
ORUs have other inherent problems which are harder to solve, unlike trust-assumptions with the sequencer which are more "induced" and hence can be solved. We discuss some of the problems(that affect us) here and a pretty simple answer(another one) for it. The main obvious limitation of an optimistic rollup is that it relies on each full node to have the capabilities to download and execute every transaction, which is not a realistic assumption. Secondly, although a minor assumption, optimistic rollups with fraud proofs(irrespective of construction) rely on the honest minority assumption, that is, there must be atleast one honest node present to challenge any invalid state. Third, trust-minimized and secure interoperability between optimistic rollups is an uphill challenge. This is because it is hard to securely verify the state of an optimistic rollup at a point in time, because an optimistic rollup inherently advances it's state optimistically, and commit's to state the same way too, except in the case where the state is invalid. Hence, it is hard to know the correct state of an optimistic rollup, without making any trust assumptions.

A simple way to solve broken interoperability is to use synchronous interoperability via tools like shared sequencers. SpiceNet will initially use Rome Protocol, which enables synchronous interopability between solana rollups. However, shared sequencing is limited to rollups that are connected to the SS, i.e rollups integrated with the SS network. And, we are also not addressing the other two problems with optimistic rollups that we discussed earlier.

# Transitioning to a full Validity rollup
The solution is again, in plain sight -- validity rollups. Validity rollups solve all of the above issues, they do not require full nodes to download and re-execute each transaction(thereby saving on bandwidth), they do not require nodes to challenge state, hence no honest minority assumptions, and a ZK proof of rollup execution is *sufficient* to enable trust-minimized interoperability, as other rollups can verify the proof to securely know the state of the rollup at any given point of time. However, there is a reason why we haven't gone with a full validity rollup already -- because of the prohibitive costs of generating and verifying a proof.

We currently use the Risc0[and soon SP1] ZKVM for the purpose of generating the ZK fraud proof. But, we do not plan on using the same ZKVMs when we transition to a full validity rollup, because of some fundamental limitations with ZKVMs and the optimizations we can make beyond ZKVMs. First, ZKVMs are able to pack in significantly less amount of computation(gates), and have a double transpilation problem -- wherein they need to convert high-level code to some machine code before proving it. These issues have massive implications on the scalability and performance of ZKVMs. We are sure that these will be addressed in the future, but we are exploring other options actively, such as using circuit compilers like ZKLLVM[most likely choice] and ZKVMs with better architecture like Valida.

We'll update this part of the document as we research further into this area.
